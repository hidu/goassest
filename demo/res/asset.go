// generated by goasset(0.6 20191001)
// https://github.com/hidu/goasset/

package res

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// AssetFile one asset file
type AssetFile interface {
	Name() string
	ModTime() time.Time
	Content() []byte
	ContentGzip() []byte
}

// assetFile asset file  struct
type assetFile struct {
	name        string
	mtime       time.Time
	content     []byte
	contentGzip []byte
}

func (af *assetFile) Name() string {
	return af.name
}
func (af *assetFile) ModTime() time.Time {
	return af.mtime
}

func (af *assetFile) Content() []byte {
	return af.content
}
func (af *assetFile) ContentGzip() []byte {
	return af.contentGzip
}

var _ AssetFile = &assetFile{}

// AssetFiles asset files
type AssetFiles interface {
	GetAssetFile(name string) (AssetFile, error)
	GetContent(name string) []byte
	GetFileNames(dir string) []string

	FileHandlerFunc(name string) http.HandlerFunc
	HTTPHandler(baseDir string) http.Handler
}

// assetFiles asset files
type assetFiles struct {
	Files map[string]*assetFile
}

var _assetDirect bool

func init() {
	exeName := filepath.Base(os.Getenv("_"))
	// only enable with go run
	if exeName == "go" || (runtime.GOOS == "windows" && strings.Contains(os.Args[0], "go-build")) {
		flag.BoolVar(&_assetDirect, "asset_direct", false, "for debug,read asset direct")
	}
}

var _assetCwd, _ = os.Getwd()

// GetAssetFile get file by name
func (afs *assetFiles) GetAssetFile(name string) (AssetFile, error) {
	name = filepath.ToSlash(name)
	if name != "" && name[0] != '/' {
		name = "/" + name
	}
	if _assetDirect {
		assetFilePath := filepath.Join(_assetCwd, name)
		f, err := os.Open(assetFilePath)
		log.Println("Asset Direct,name=", name, "assetPath=", assetFilePath, "err=", err)

		if err != nil {
			return nil, err
		}
		defer f.Close()
		info, err := f.Stat()
		if err != nil {
			return nil, err
		}
		if info.Mode().IsRegular() {
			content, err := ioutil.ReadAll(f)
			if err != nil {
				return nil, err
			}
			return &assetFile{
				content: content,
				name:    name,
				mtime:   info.ModTime(),
			}, nil
		}
		return nil, fmt.Errorf("not file")
	}
	if sf, has := afs.Files[name]; has {
		return sf, nil
	}
	return nil, fmt.Errorf("not exists")
}

// GetContent get content by name
func (afs *assetFiles) GetContent(name string) []byte {
	s, err := afs.GetAssetFile(name)
	if err != nil {
		return []byte("")
	}
	return s.Content()
}

// GetFileNames get all file names
func (afs *assetFiles) GetFileNames(dir string) []string {
	if dir == "" {
		dir = "/"
	}
	names := make([]string, 0, len(afs.Files))
	dirRaw := dir
	dir = path.Clean(dir)

	if dir != "/" && strings.HasSuffix(dirRaw, "/") {
		dir += string(filepath.Separator)
	}

	dir = filepath.ToSlash(dir)

	for name := range afs.Files {
		if strings.HasPrefix(name, dir) {
			names = append(names, name)
		}
	}
	return names
}

// FileHandlerFunc handler http files
func (afs *assetFiles) FileHandlerFunc(name string) http.HandlerFunc {
	if strings.Contains(name, "private") {
		return http.NotFound
	}
	name = filepath.ToSlash(name)
	file, err := afs.GetAssetFile(name)
	return func(writer http.ResponseWriter, req *http.Request) {
		if err != nil {
			http.NotFound(writer, req)
			return
		}
		modifiedSince := req.Header.Get("If-Modified-Since")
		if modifiedSince != "" {
			t, err := time.Parse(http.TimeFormat, modifiedSince)
			if err == nil && file.ModTime().Before(t) {
				writer.Header().Del("Content-Type")
				writer.Header().Del("Content-Length")
				writer.Header().Set("Last-Modified", file.ModTime().UTC().Format(http.TimeFormat))
				writer.WriteHeader(http.StatusNotModified)
				return
			}
		}

		mimeType := mime.TypeByExtension(filepath.Ext(file.Name()))
		if mimeType != "" {
			writer.Header().Set("Content-Type", mimeType)
		}
		writer.Header().Set("Last-Modified", file.ModTime().UTC().Format(http.TimeFormat))

		gzipContent := file.ContentGzip()

		if len(gzipContent) > 0 && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			writer.Header().Set("Content-Encoding", "gzip")
			writer.Write(gzipContent)
		} else {
			writer.Write(file.Content())
		}
	}
}

// HTTPHandler handler http request
// eg:on file system is :/res/js/a.js and request is /res/js/a.js
// http.Handle("/res/",res.Asset.HttpHandler("/"))

// eg:on file system is :/res/js/a.js and request is /js/a.js
// http.Handle("/js/",res.Asset.HttpHandler("/res/"))
func (afs *assetFiles) HTTPHandler(baseDir string) http.Handler {
	return &_assetFileServer{sf: afs, pdir: baseDir}
}

type _assetFileServer struct {
	sf   *assetFiles
	pdir string
}

// ServeHTTP ServeHTTP
func (f *_assetFileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := filepath.ToSlash(filepath.Join(f.pdir, r.URL.Path))
	f.sf.FileHandlerFunc(name).ServeHTTP(w, r)
}

func _assetGzipBase64decode(data string) []byte {
	bf := _assetBase64Decode(data)
	gzipReader, errGzip := gzip.NewReader(bytes.NewBuffer(bf))
	if errGzip != nil {
		panic("data in wrong format, gzip decode failed:" + errGzip.Error())
	}
	buf, errReader := ioutil.ReadAll(gzipReader)
	if errReader != nil {
		panic("data in wrong format, ioutil.ReadAll failed:" + errReader.Error())
	}
	return buf
}

func _assetBase64Decode(data string) []byte {
	bf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		panic("data in wrong format, base64 decode failed:" + err.Error())
	}
	return bf
}

var _ AssetFiles = &assetFiles{}

// Asset export assets
var Asset AssetFiles

func init() {
	asset := &assetFiles{Files: map[string]*assetFile{}}
	Asset = asset

	{
		fileName := string(_assetBase64Decode("L3Jlcy9iLmNzcw=="))
		contentGzBase64 := "H4sIAAAAAAAA/8owrE7LzyvRLc6sSrUysSiosE7Oz8kvskovSk3Nq80wroZwi1JTajNMkDgAAAAA//8BAAD///xF3Xc4AAAA"
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1440515205, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := string(_assetBase64Decode("L3Jlcy9pbmRleC5odG1s"))
		contentGzBase64 := "H4sIAAAAAAAA/5yTv2+7MBDFd/6Ki3fi/GD4DoeXb9u1HdKhU2XMEUOcgOxT2/z3lU0qkTRSo0xIx+fde/BsnD08/9+8vTyC5b1TGf48SNcqwz2xBmO1D8SleN085f+EypBbdqQsOdeDDoEY5TjK0LWHHXhypQh8dBQsEQvg40ClYPpiaUIQYD01pZCegqzmcaIyDMa3A0/RTn/ocSogeHMSdEHqeReEQjm+vFHbRa+7dCvZXAhvUwbW3JpobO7Sx6+dqABneQ7FooA8vzH7oLdULIrpkost8tR01dfHmMsuT71+9t7VKO1SZTgo1L87A9Z+G8/Fe+X0YSdUGqPUCuWgsrhspbZ9OiBQ075HaVfJYw1tXYrkE6PZtUqhYq1g+gP33kHLKeA5nVdTvrrCn+Nmips/8WaKN9dwOf4nlOmefAMAAP//AQAA//8u9YzkPgMAAA=="
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1569894508, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := string(_assetBase64Decode("L3Jlcy9qcy9hLmpz"))
		contentGzBase64 := "H4sIAAAAAAAA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LylTT1MvPyUos8Qnx9bCFCOol6WcUKRkrWtTqGBgYGmtYAAAAA//8BAAD//4rtx7JYAAAA"
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1440515205, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := string(_assetBase64Decode("L3Jlcy9qcy9iLmpz"))
		contentGzBase64 := "H4sIAAAAAAAA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LydZOUNPUy8/JSizxCfH1sIYI6SXpZxQpGSta1OoYGBgaa1gAAAAD//wEAAP//8g4AUloAAAA="
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1463832956, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := string(_assetBase64Decode("L3Jlcy9qcy9jLmpz"))
		contentGzBase64 := "H4sIAAAAAAAA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LydZOVNPUy8/JSizxCfH1sIYI6yXpZxQpGSta1OoYGBgaa1gAAAAD//wEAAP//fIiYfFoAAAA="
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1463833139, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := string(_assetBase64Decode("L3JlczIvZi5qcw=="))
		contentGzBase64 := "H4sIAAAAAAAA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LyddOUNPUy8/JSizxCfH1sIYI6aXpZxQqmSta1OoYGBgaa1gAAAAD//wEAAP//SQFZwVoAAAA="
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1464878943, 0),
			content:     _assetGzipBase64decode(contentGzBase64),
			contentGzip: _assetBase64Decode(contentGzBase64),
		}
		asset.Files[fileName] = oneFile
	}

}
