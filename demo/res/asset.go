package res

// Generated by goasset(1.0 20191009). DO NOT EDIT.
// https://github.com/hidu/goasset/

import (
	"bytes"
	"compress/gzip"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"
)

// AssetFile one asset file
type AssetFile interface {
	Name() string
	ModTime() time.Time
	Content() []byte
	ContentGzip() []byte
}

// assetFile asset file  struct
type assetFile struct {
	name        string
	mtime       time.Time
	content     []byte
	contentGzip []byte
}

func (af *assetFile) Name() string {
	return af.name
}
func (af *assetFile) ModTime() time.Time {
	return af.mtime
}

func (af *assetFile) Content() []byte {
	return af.content
}
func (af *assetFile) ContentGzip() []byte {
	return af.contentGzip
}

var _ AssetFile = &assetFile{}

// AssetFiles asset files
type AssetFiles interface {
	GetAssetFile(name string) (AssetFile, error)
	GetContent(name string) []byte
	GetFileNames(dir string) []string

	FileHandlerFunc(name string) http.HandlerFunc
	HTTPHandler(baseDir string) http.Handler
}

// assetFiles asset files
type assetFiles struct {
	Files map[string]*assetFile
}

var _assetDirect bool

func init() {
	exeName := filepath.Base(os.Getenv("_"))
	// only enable with go run
	if exeName == "go" || (runtime.GOOS == "windows" && strings.Contains(os.Args[0], "go-build")) {
		flag.BoolVar(&_assetDirect, "asset_direct", false, "for debug,read asset direct")
	}
}

var _assetCwd, _ = os.Getwd()

// GetAssetFile get file by name
func (afs *assetFiles) GetAssetFile(name string) (AssetFile, error) {
	name = filepath.ToSlash(name)
	if name != "" && name[0] != '/' {
		name = "/" + name
	}
	if _assetDirect {
		assetFilePath := filepath.Join(_assetCwd, name)
		f, err := os.Open(assetFilePath)
		log.Println("Asset Direct, name=", name, "assetPath=", assetFilePath, "err=", err)

		if err != nil {
			return nil, err
		}
		defer f.Close()
		info, err := f.Stat()
		if err != nil {
			return nil, err
		}
		if info.Mode().IsRegular() {
			content, err := ioutil.ReadAll(f)
			if err != nil {
				return nil, err
			}

			helper := newAssetHelper()
			contentNew, errHelper := helper.Execute(assetFilePath, content, "")
			if errHelper != nil {
				return nil, errHelper
			}
			return &assetFile{
				content: contentNew,
				name:    name,
				mtime:   info.ModTime(),
			}, nil
		}
		return nil, fmt.Errorf("not file")
	}
	if sf, has := afs.Files[name]; has {
		return sf, nil
	}
	return nil, fmt.Errorf("not exists")
}

// GetContent get content by name
func (afs *assetFiles) GetContent(name string) []byte {
	s, err := afs.GetAssetFile(name)
	if err != nil {
		return []byte("")
	}
	return s.Content()
}

// GetFileNames get all file names
func (afs *assetFiles) GetFileNames(dir string) []string {
	if dir == "" {
		dir = "/"
	}
	names := make([]string, 0, len(afs.Files))
	dirRaw := dir
	dir = path.Clean(dir)

	if dir != "/" && strings.HasSuffix(dirRaw, "/") {
		dir += string(filepath.Separator)
	}

	dir = filepath.ToSlash(dir)

	for name := range afs.Files {
		if strings.HasPrefix(name, dir) {
			names = append(names, name)
		}
	}
	return names
}

// FileHandlerFunc handler http files
func (afs *assetFiles) FileHandlerFunc(name string) http.HandlerFunc {
	if strings.Contains(name, "private") {
		return http.NotFound
	}
	name = filepath.ToSlash(name)
	file, err := afs.GetAssetFile(name)
	return func(writer http.ResponseWriter, req *http.Request) {
		if err != nil {
			http.NotFound(writer, req)
			return
		}
		modifiedSince := req.Header.Get("If-Modified-Since")
		if modifiedSince != "" {
			t, err := time.Parse(http.TimeFormat, modifiedSince)
			if err == nil && file.ModTime().Before(t) {
				writer.Header().Del("Content-Type")
				writer.Header().Del("Content-Length")
				writer.Header().Set("Last-Modified", file.ModTime().UTC().Format(http.TimeFormat))
				writer.WriteHeader(http.StatusNotModified)
				return
			}
		}

		mimeType := mime.TypeByExtension(filepath.Ext(file.Name()))
		if mimeType != "" {
			writer.Header().Set("Content-Type", mimeType)
		}
		writer.Header().Set("Last-Modified", file.ModTime().UTC().Format(http.TimeFormat))

		gzipContent := file.ContentGzip()

		if len(gzipContent) > 0 && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			writer.Header().Set("Content-Encoding", "gzip")
			writer.Write(gzipContent)
		} else {
			writer.Write(file.Content())
		}
	}
}

// HTTPHandler handler http request
// eg:on file system is :/res/js/a.js and request is /res/js/a.js
// http.Handle("/res/",res.Asset.HttpHandler("/"))

// eg:on file system is :/res/js/a.js and request is /js/a.js
// http.Handle("/js/",res.Asset.HttpHandler("/res/"))
func (afs *assetFiles) HTTPHandler(baseDir string) http.Handler {
	return &_assetFileServer{sf: afs, pdir: baseDir}
}

type _assetFileServer struct {
	sf   *assetFiles
	pdir string
}

// ServeHTTP ServeHTTP
func (f *_assetFileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := filepath.ToSlash(filepath.Join(f.pdir, r.URL.Path))
	f.sf.FileHandlerFunc(name).ServeHTTP(w, r)
}

func _assetGzipDecode(data []byte) []byte {
	gzipReader, errGzip := gzip.NewReader(bytes.NewBuffer(data))
	if errGzip != nil {
		panic("data in wrong format, gzip decode failed:" + errGzip.Error())
	}
	buf, errReader := ioutil.ReadAll(gzipReader)
	if errReader != nil {
		panic("data in wrong format, ioutil.ReadAll failed:" + errReader.Error())
	}
	return buf
}

var _ AssetFiles = &assetFiles{}

//---------------------------helper.go--------begin--------------------------//

func newAssetHelper() *assetHelper {
	helper := &assetHelper{}

	helper.Regs = make(map[string]*regexp.Regexp)
	helper.Regs["remove_above"] = regexp.MustCompile(`[\S\s]*?//\s*asset_remove_above\(\s*\)`)
	helper.Regs["remove"] = regexp.MustCompile(`//\s*asset_remove_start\(\s*\)[\S\s]*?//\s*asset_remove_end\(\s*\)`)
	helper.Regs["include"] = regexp.MustCompile(`//\s*asset_include\(([^)]+?)\)`)

	helper.RegisterFn("remove_above", helper.RemoveAbove)
	helper.RegisterFn("include", helper.Include)
	helper.RegisterFn("remove", helper.Remove)

	return helper
}

type assetHelperFn func(fileName string, content []byte) ([]byte, error)

type assetHelper struct {
	Fns  []map[string]assetHelperFn
	Regs map[string]*regexp.Regexp
}

func (h *assetHelper) RegisterFn(name string, fn assetHelperFn) {
	h.Fns = append(h.Fns, map[string]assetHelperFn{name: fn})
}

func (h *assetHelper) Execute(fileAbsPath string, content []byte, skipFnName string) (contentNew []byte, err error) {
	contentNew = make([]byte, len(content))
	copy(contentNew, content)

	for _, fnInfo := range h.Fns {
		for name, fn := range fnInfo {
			if name == skipFnName {
				continue
			}
			contentNew, err = fn(fileAbsPath, contentNew)
			if err != nil {
				return nil, fmt.Errorf("%s,current file is: %s", err.Error(), fileAbsPath)
			}
		}
	}

	return contentNew, nil
}

// RemoveAbove 删除在此标记之前的内容
// eg: \/\/ asset_remove_above()
func (h *assetHelper) RemoveAbove(fileAbsPath string, content []byte) (contentNew []byte, err error) {
	contentNew = h.Regs["remove_above"].ReplaceAll(content, []byte(""))
	return contentNew, nil
}

// Remove remove 方法, 删除指定区间里的内容
// eg: \/\/asset_remove_start() 中间的内容被删除 \/\/ asset_remove_end()
func (h *assetHelper) Remove(fileAbsPath string, content []byte) (contentNew []byte, err error) {
	contentNew = h.Regs["remove"].ReplaceAll(content, []byte(""))
	return contentNew, nil
}

func (h *assetHelper) include(fileAPath string, content []byte, includeFiles map[string]map[string]bool) (contentNew []byte, err error) {

	fileAPath = filepath.Clean(fileAPath)
	includeFiles[fileAPath] = make(map[string]bool)

	contentNew = h.Regs["include"].ReplaceAllFunc(content, func(matchData []byte) []byte {
		idx := bytes.Index(matchData, []byte("("))
		name := bytes.TrimSpace(matchData[idx+1 : len(matchData)-1])
		if len(name) == 0 {
			err = fmt.Errorf("asset_include with empty param")
			return []byte(err.Error())
		}
		fileBPath := filepath.Join(filepath.Dir(fileAPath), string(name))

		if bFiles, hasB := includeFiles[fileBPath]; hasB {
			if _, hasA := bFiles[fileAPath]; hasA {
				err = fmt.Errorf("asset_include error: cyclic include,%s include(%s)", fileAPath, string(name))
				return []byte(err.Error())
			}
		}
		includeFiles[fileAPath][fileBPath] = true

		includeFiles[fileBPath] = make(map[string]bool)

		bContent, errRead := ioutil.ReadFile(fileBPath)
		if errRead != nil {
			err = errRead
			return []byte(err.Error())
		}

		b1Content, errB1 := h.Execute(fileBPath, bContent, "include")
		if errB1 != nil {
			err = errB1
			return []byte(err.Error())
		}

		cContent, errInclude := h.include(fileBPath, b1Content, includeFiles)
		if errInclude != nil {
			err = errInclude
			return []byte(err.Error())
		}
		return cContent
	})

	if err != nil {
		return nil, err
	}
	return contentNew, nil
}

// Include 将另外一个资源文件包含到当前文件里
// eg: \/\/ asset_include(a.tpl)
func (h *assetHelper) Include(fileAPath string, content []byte) (contentNew []byte, err error) {
	// 用于检查循环include
	includeFiles := make(map[string]map[string]bool)
	return h.include(fileAPath, content, includeFiles)
}

//---------------------------helper.go--------finish-------------------------//

// Asset export assets
var Asset AssetFiles

func init() {
	asset := &assetFiles{Files: map[string]*assetFile{}}
	Asset = asset

	{
		fileName := "/res/b.css"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff\xca0\xacN\xcb\xcf+\xd1-άJ\xb52\xb1(\xa8\xb0N\xce\xcf\xc9/\xb2J/JMͫ\xcd0\xae\x86p\x8bRSj3L\x908\x00\x00\x00\x00\xff\xff\x01\x00\x00\xff\xff\xfcE\xddw8\x00\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1440515205, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := "/res/index.html"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff\x9c\x93\xbfo\xbb0\x10\xc5w\xfe\x8a\x8bw\xe2\xfc`\xf8\x0e\x87\x97o۵\x1dҡSe\xcc\x11C\x9c\x80\xecS\xdb\xfc\xf7\x95M*\x914R\xa3LH\xc7\xe7\xdd{\xf0l\x9c=<\xff\u07fc\xbd<\x82\xe5\xbdS\x19\xfe<H\xd7*\xc3=\xb1\x06c\xb5\x0fĥx\xdd<\xe5\xff\x84ʐ[v\xa4,9׃\x0e\x81\x18\xe58\xcaе\x87\x1dxr\xa5\b|t\x14,\x11\v\xe0\xe3@\xa5`\xfabiB\x10`=5\xa5\x90\x9e\x82\xac\xe6q\xa22\fƷ\x03O\xd1N\u007f\xe8q* xs\x12tA\xeay\x17\x84B9\xbe\xbcQ\xdbE\xaf\xbbt+\xd9\\\boS\x06\xd6ܚhl\xee\xd2ǯ\x9d\xa8\x00gy\x0eŢ\x80<\xbf1\xfb\xa0\xb7T,\x8a钋-\xf2\xd4t\xd5\xd7ǘ\xcb.O\xbd~\xf6\xde\xd5(\xedRe8(Կ;\x03\xd6~\x1b\xcf\xc5{\xe5\xf4a'T\x1a\xa3\xd4\n堲\xb8l\xa5\xb6}: PӾGiW\xc9c\rm]\x8a\xe4\x13\xa3ٵJ\xa1b\xad`\xfa\x03\xf7\xdeA\xcb)\xe09\x9dWS\xbe\xba\u009f\xe3f\x8a\x9b?\xf1f\x8a7\xd7p9\xfe'\x94\xe9\x9e|\x03\x00\x00\xff\xff\x01\x00\x00\xff\xff.\xf5\x8c\xe4>\x03\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1569894508, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := "/res/js/a.js"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff*N-\t\xc9\xccM\xcd/-\xd1H+\xcdK.\xc9\xcc\xcf\xd3ЬN\xc9O.\xcdM\xcd+\xd1KO-q\xcdI\x051\x9d*=S4\x942Rsr\xf2\x954\xf52\xf3\xf2R\x8b<B|}l!B:\x89zY\xc5\nFJֵ:\x86\x06\x06\x06\x9a\xd6\x00\x00\x00\x00\xff\xff\x01\x00\x00\xff\xff\x8a\xedǲX\x00\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1440515205, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := "/res/js/b.js"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff*N-\t\xc9\xccM\xcd/-\xd1H+\xcdK.\xc9\xcc\xcf\xd3ЬN\xc9O.\xcdM\xcd+\xd1KO-q\xcdI\x051\x9d*=S4\x942Rsr\xf2u\x93\x944\xf52\xf3\xf2R\x8b<B|}l!\x82:IzY\xc5\nFJֵ:\x86\x06\x06\x06\x9a\xd6\x00\x00\x00\x00\xff\xff\x01\x00\x00\xff\xff\xf2\x0e\x00RZ\x00\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1463832956, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := "/res/js/c.js"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff*N-\t\xc9\xccM\xcd/-\xd1H+\xcdK.\xc9\xcc\xcf\xd3ЬN\xc9O.\xcdM\xcd+\xd1KO-q\xcdI\x051\x9d*=S4\x942Rsr\xf2u\x93\x954\xf52\xf3\xf2R\x8b<B|}l!\x82:\xc9zY\xc5\nFJֵ:\x86\x06\x06\x06\x9a\xd6\x00\x00\x00\x00\xff\xff\x01\x00\x00\xff\xff|\x88\x98|Z\x00\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1463833139, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

	{
		fileName := "/res2/f.js"
		contentGz := []byte("\x1f\x8b\b\x00\x00\x00\x00\x00\x00\xff*N-\t\xc9\xccM\xcd/-\xd1H+\xcdK.\xc9\xcc\xcf\xd3ЬN\xc9O.\xcdM\xcd+\xd1KO-q\xcdI\x051\x9d*=S4\x942Rsr\xf2uӔ4\xf52\xf3\xf2R\x8b<B|}l!\x82:izY\xc5\n\xa6Jֵ:\x86\x06\x06\x06\x9a\xd6\x00\x00\x00\x00\xff\xff\x01\x00\x00\xff\xffI\x01Y\xc1Z\x00\x00\x00")
		oneFile := &assetFile{
			name:        fileName,
			mtime:       time.Unix(1464878943, 0),
			content:     _assetGzipDecode(contentGz),
			contentGzip: contentGz,
		}
		asset.Files[fileName] = oneFile
	}

}
