package main

import (
	"text/template"
)

var tpl = template.Must(template.New("static").Parse(`
// generated by goasset({{$.version}})
// https://github.com/hidu/goasset/

package {{.package}}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// AssetFile asset file  struct
type AssetFile struct{
	Name string
	Mtime int64
	Content []byte
}

// AssetFile asset files
type AssetStruct struct{
  Files  map[string]*AssetFile
}

var _assetDirect bool

func init(){
	exeName:=filepath.Base(os.Getenv("_"))
	// only enable with go run
	if(exeName=="go" || (runtime.GOOS=="windows" && strings.Contains(os.Args[0], "go-build") ) ){
		flag.BoolVar(&_assetDirect, "asset_direct", false, "for debug,read asset direct")
	}
}

var _assetCwd,_=os.Getwd()

// GetAssetFile get file by name
func (statics *AssetStruct)GetAssetFile(name string) (*AssetFile,error){
	name=filepath.ToSlash(name)
	if name!="" && name[0]!='/' {
		name="/"+name
	}
	if _assetDirect {
		f,err:=os.Open(filepath.Join(_assetCwd,name))
		if err!=nil{
			return nil,err
		}
		defer f.Close()
		info,err:=f.Stat()
		if err!=nil{
			return nil,err
		}
		if info.Mode().IsRegular(){
			content,err:=ioutil.ReadAll(f)
			if err!=nil {
				return nil,err
			}
			return &AssetFile{
				Content:content,
				Name:name,
				Mtime:info.ModTime().Unix(),
			},nil
		}
		return nil,fmt.Errorf("not file")
	}
	if sf,has:=statics.Files[name];has{
		return sf,nil
	}
	return nil,fmt.Errorf("not exists")
}

// GetContent get content by name
func (statics *AssetStruct)GetContent(name string)[]byte{
	s,err:=statics.GetAssetFile(name)
	if err!=nil{
		return []byte("")
	}
	return s.Content
}

// GetFileNames get all file names
func (statics *AssetStruct)GetFileNames(dir string)[]string{
	if dir=="" {
		dir="/"
	}
	names:=make([]string,len(statics.Files))
		dirRaw:=dir
	dir = path.Clean(dir) 
	
	if dir!="/" && strings.HasSuffix(dirRaw,"/") {
		dir+=string(filepath.Separator)
	}
	 
	dir=filepath.ToSlash(dir)
	
	for name:=range statics.Files{
		if strings.HasPrefix(name,dir){
			names=append(names,name)
		}
	}
	return names
}

// FileHandlerFunc handler http files
func (statics *AssetStruct)FileHandlerFunc(name string) http.HandlerFunc{
	if strings.Contains(name,"private"){
		return http.NotFound
	}
	name=filepath.ToSlash(name)
	static, err := statics.GetAssetFile(name)
	return func(w http.ResponseWriter,r *http.Request){
		if err!=nil{
			http.NotFound(w, r)
			return
		}
		mtime := time.Unix(static.Mtime, 0)
		modifiedSince := r.Header.Get("If-Modified-Since")
		if modifiedSince != "" {
			t, err := time.Parse(http.TimeFormat, modifiedSince)
			if err == nil && mtime.Before(t.Add(1*time.Second)) {
				w.Header().Del("Content-Type")
				w.Header().Del("Content-Length")
				w.Header().Set("Last-Modified", mtime.UTC().Format(http.TimeFormat))
				w.WriteHeader(http.StatusNotModified)
				return
			}
		}
	
		mimeType := mime.TypeByExtension(filepath.Ext(static.Name))
		if mimeType != "" {
			w.Header().Set("Content-Type", mimeType)
		}
		w.Header().Set("Last-Modified", mtime.UTC().Format(http.TimeFormat))
		w.Write(static.Content)
	}
}

// HTTPHandler handler http request
// eg:on file system is :/res/js/a.js and request is /res/js/a.js
// http.Handle("/res/",res.Asset.HttpHandler("/"))

// eg:on file system is :/res/js/a.js and request is /js/a.js
// http.Handle("/js/",res.Asset.HttpHandler("/res/")) 
func (statics *AssetStruct)HTTPHandler(baseDir string)http.Handler{
	return &_assetFileServer{sf:statics,pdir:baseDir}
}



type _assetFileServer struct{
	sf *AssetStruct
	pdir string
}


// ServeHTTP ServeHTTP
func (f *_assetFileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name:=filepath.ToSlash(filepath.Join(f.pdir,r.URL.Path))
	f.sf.FileHandlerFunc(name).ServeHTTP(w,r)
}


func _assetGzipBase64decode(data string)[]byte{
  b,_:=base64.StdEncoding.DecodeString(data)
  gr, _:= gzip.NewReader(bytes.NewBuffer(b))
  bs, _ := ioutil.ReadAll(gr)
  return bs
}

func _assetBase64Decode(data string)string{
   b,_:=base64.StdEncoding.DecodeString(data)
   return string(b)
}

// Asset export assets
var Asset = &AssetStruct{
	Files:map[string]*AssetFile{
	   {{range $file := .files}}
	      _assetBase64Decode("{{$file.Name}}"):&AssetFile{
	         Name:_assetBase64Decode("{{$file.Name}}"),
	         Mtime:{{$file.Mtime}},
	         Content:_assetGzipBase64decode("{{$file.Content}}"),
	       },
		{{end}}
	},
}

`))
