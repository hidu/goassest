/**
* generated by goassest
* https://github.com/hidu/goassest/
 */
package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"time"
)

type StaticFile struct {
	Name    string
	Mtime   int64
	Content string
}

type StaticFiles map[string]*StaticFile

//for debug
var DebugAssestDir string = ""

func (statics StaticFiles) GetStaticFile(name string) (*StaticFile, error) {
	if DebugAssestDir != "" {
		return getStaticFile(DebugAssestDir, name)
	}
	if sf, has := statics[path.Clean(name)]; has {
		return sf, nil
	}
	return nil, fmt.Errorf("not exists")
}

func (statics StaticFiles) GetContent(name string) string {
	s, err := statics.GetStaticFile(name)
	if err != nil {
		return ""
	}
	return s.Content
}

func getStaticFile(baseDir string, name string) (*StaticFile, error) {
	fullPath := baseDir + string(filepath.Separator) + name
	f, err := os.Open(fullPath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	info, err := f.Stat()
	if err != nil {
		return nil, err
	}
	if info.Mode().IsRegular() {
		content, err := ioutil.ReadAll(f)
		if err != nil {
			return nil, err
		}
		return &StaticFile{
			Content: string(content),
			Name:    name,
			Mtime:   info.ModTime().Unix(),
		}, nil
	}
	return nil, fmt.Errorf("not file")
}

/**
*res.DebugAssestDir="../";//for debug read it direct
*http.Handle("/res/",res.Files.HttpHandler("/res/"))
 */
func (statics *StaticFiles) HttpHandler(pdir string) http.Handler {
	return &fileServer{sf: statics, pdir: pdir}
}

func decode(data string) string {
	b, _ := base64.StdEncoding.DecodeString(data)
	gr, _ := gzip.NewReader(bytes.NewBuffer(b))
	bs, _ := ioutil.ReadAll(gr)
	return string(bs)
}

func base64decode(data string) string {
	b, _ := base64.StdEncoding.DecodeString(data)
	return string(b)
}

type fileServer struct {
	sf   *StaticFiles
	pdir string
}

func (f *fileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	rname, _ := filepath.Rel(f.pdir, r.URL.Path)
	static, err := f.sf.GetStaticFile(rname)
	if err != nil {
		http.NotFound(w, r)
		return
	}
	modtime := time.Unix(static.Mtime, 0)
	modifiedSince := r.Header.Get("If-Modified-Since")
	if modifiedSince != "" {
		t, err := time.Parse(http.TimeFormat, modifiedSince)
		if err == nil && modtime.Before(t.Add(1*time.Second)) {
			h := w.Header()
			delete(h, "Content-Type")
			delete(h, "Content-Length")
			w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
			w.WriteHeader(http.StatusNotModified)
			return
		}
	}

	mimeType := mime.TypeByExtension(filepath.Ext(static.Name))
	if mimeType != "" {
		w.Header().Set("Content-Type", mimeType)
	}
	w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
	w.Write([]byte(static.Content))
}

var Files = StaticFiles{}
